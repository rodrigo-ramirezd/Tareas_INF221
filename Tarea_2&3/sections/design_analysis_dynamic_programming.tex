\epigraph{\textit{Dynamic programming is not about filling in tables. It's about smart recursion!}}{\citeauthor{algorithms_erickson}, \citeyear{algorithms_erickson} \cite{algorithms_erickson}}


\subsubsection{Descripción de la solución recursiva}

La solución por programación dinámica se implementa usando una estrategia de tabulación (enfoque \textit{Bottom-Up}), en la cual se utiliza una matriz para almacenar los costos de cada operación de edición (inserción, eliminación, sustitución y transposición) entre caracteres de las cadenas \texttt{S1} y \texttt{S2}. La matriz tiene dimensiones \( 4 \times N \), donde \( N \) representa la longitud de \texttt{S1} y el valor 4 corresponde a las cuatro operaciones posibles.

Para calcular la distancia mínima, se rellena la matriz por columnas. Cada columna representa el costo acumulado de transformar un carácter de \texttt{S1} en el carácter correspondiente de \texttt{S2} mediante una de las operaciones. El primer elemento de cada columna se inicializa en 0 si los caracteres de \texttt{S1} y \texttt{S2} son iguales, ya que no requiere ninguna operación; en caso contrario, se calcula su costo.

Para la siguiente fila (operación de costo mínimo para el mismo carácter), se evalúa el costo y se almacena el mínimo entre el costo calculado y el costo acumulado de la operación anterior. Este proceso asegura que cada columna contenga el costo mínimo de las cuatro operaciones para un carácter dado, y además, se suma el costo acumulado de la columna anterior para reflejar el costo de transformación secuencial. Al finalizar, el valor en la última celda de la matriz representa el costo mínimo o distancia de edición entre las dos cadenas.

\subsubsection{Relación de recurrencia}

La relación de recurrencia establece el costo mínimo para transformar un prefijo de \texttt{S1} en un prefijo de \texttt{S2}. Se define como:
\[
D(i, j) = \min \begin{cases} 
      D(i-1, j) + \text{COSTO\_DEL}(\texttt{S1}[i-1]) & \text{(eliminación)} \\
      D(i, j-1) + \text{COSTO\_INS}(\texttt{S2}[j-1]) & \text{(inserción)} \\
      D(i-1, j-1) + \text{COSTO\_SUB}(\texttt{S1}[i-1], \texttt{S2}[j-1]) & \text{(sustitución)} \\
      D(i-2, j-2) + \text{COSTO\_TRANS}(\texttt{S1}[i-2], \texttt{S1}[i-1]) & \text{(transposición)}
   \end{cases}
\]
con los casos base:
\[
D(i, 0) = i \cdot \text{COSTO\_DEL}(\texttt{S1}[i-1])
\]
\[
D(0, j) = j \cdot \text{COSTO\_INS}(\texttt{S2}[j-1])
\]
\\
\subsubsection{Identificación de subproblemas}

Cada subproblema consiste en calcular el costo mínimo de transformar un prefijo de \texttt{S1} en un prefijo de \texttt{S2}. Esto se traduce en encontrar la mínima cantidad de operaciones para cada prefijo de longitud \( i \) y \( j \) de \texttt{S1} y \texttt{S2}, respectivamente. Al resolver estos subproblemas y almacenarlos en la matriz, se evita la recalculación redundante y se optimiza el cálculo de la solución final.

\subsubsection{Estructura de datos y orden de cálculo}

La estructura de datos utilizada es una matriz bidimensional \( D[i][j] \), donde \( D[i][j] \) almacena el costo mínimo para transformar el prefijo de longitud \( i \) de \texttt{S1} en el prefijo de longitud \( j \) de \texttt{S2}. La matriz se rellena secuencialmente desde la esquina superior izquierda hasta la esquina inferior derecha, asegurando que cada valor \( D[i][j] \) dependa únicamente de valores previamente calculados.

\subsubsection{Algoritmo utilizando programación dinámica}

\begin{algorithm}[H]
    \SetKwProg{myproc}{Procedure}{}{}
    \SetKwFunction{DistanciaMinima}{DistanciaMinima}
    
    \DontPrintSemicolon
    \footnotesize

    % Definición del algoritmo principal
    \myproc{\DistanciaMinima{S1, S2}}{
        $n \leftarrow \text{longitud de } S1$\;
        $m \leftarrow \text{longitud de } S2$\;
        Crear matriz $D$ de tamaño $(n+1) \times (m+1)$\;
        
        \For{$i \leftarrow 0$ \KwTo $n$}{
            $D[i][0] \leftarrow i \times \text{COSTO\_DEL}(S1[i-1])$\;
        }
        \For{$j \leftarrow 0$ \KwTo $m$}{
            $D[0][j] \leftarrow j \times \text{COSTO\_INS}(S2[j-1])$\;
        }
        
        \For{$i \leftarrow 1$ \KwTo $n$}{
            \For{$j \leftarrow 1$ \KwTo $m$}{
                $costo\_del \leftarrow D[i-1][j] + \text{COSTO\_DEL}(S1[i-1])$\;
                $costo\_ins \leftarrow D[i][j-1] + \text{COSTO\_INS}(S2[j-1])$\;
                $costo\_sub \leftarrow D[i-1][j-1] + \text{COSTO\_SUB}(S1[i-1], S2[j-1])$\;
                
                \uIf{$i > 1 \land j > 1 \land S1[i-1] = S2[j-2] \land S1[i-2] = S2[j-1]$}{
                    $costo\_trans \leftarrow D[i-2][j-2] + \text{COSTO\_TRANS}(S1[i-2], S1[i-1])$\;
                }
                \Else{
                    $costo\_trans \leftarrow \infty$\;
                }
                
                $D[i][j] \leftarrow \min(costo\_del, costo\_ins, costo\_sub, costo\_trans)$\;
            }
        }
        \Return $D[n][m]$\;
    }
    \caption{Algoritmo de Programación Dinámica para la distancia mínima de edición entre dos cadenas.}
    \label{alg:mi_algoritmo_pd}
\end{algorithm}
