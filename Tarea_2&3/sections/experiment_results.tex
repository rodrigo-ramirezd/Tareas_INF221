En esta sección se presentan los resultados de ambos enfoques algorítmicos mediante gráficos de dispersión, considerando los costos y archivos de entrada disponibles en el repositorio de GitHub referenciado en la sección de Implementación. Cabe destacar que estos archivos no han sido ni serán modificados, lo que permite verificar la reproducibilidad de los resultados.

Para replicar los experimentos, basta con ejecutar los comandos \texttt{make} mencionados anteriormente, ingresando manualmente los datos de entrada que se encuentran en los archivos \texttt{.txt}. Aunque sería posible automatizar todos los casos mediante \texttt{make}, esto haría el proceso innecesariamente complejo y menos flexible para el usuario, limitando la posibilidad de probar casos específicos de forma manual. Para detalles sobre la compilación y ejecución de los programas \texttt{.cpp}, puede utilizar el comando \textbf{\texttt{make help}} en la terminal. Es importante asegurarse de que el sistema tenga un compilador compatible con archivos \texttt{.cpp} y soporte para \texttt{make}, de lo contrario, los comandos no funcionarán correctamente.

En la \cref{fig:grafico_dispersion_1}, se presentan los resultados obtenidos al ejecutar los cinco casos del dataset \textit{transpose}. La gráfica muestra un claro crecimiento exponencial en el tiempo de ejecución del algoritmo basado en \textit{Fuerza Bruta} (puntos en color azul), mientras que el enfoque de \textit{Programación Dinámica} (puntos en color naranja) mantiene un crecimiento lineal. Se observan casos anómalos, por ejmplo cuando la longitud de \( S1 \) es 5 utilizando el enfoque de fuerza bruta, los cuales podrían ser explicados por variaciones en la gestión de memoria o costos específicos.

\begin{figure}[H]
    \centering
    \input{tikz/plot1.tex}
    \caption{Gráfica de dispersión para \textit{transpose dataset}, contrastando el uso del enfoque de fuerza bruta y el de programación dinámica.}
    \label{fig:grafico_dispersion_1}
\end{figure}

En las siguientes figuras (\cref{fig:grafico_dispersion_2} y \cref{fig:grafico_dispersion_3}), se muestran los resultados obtenidos para los datasets \textit{semiordered} y \textit{disordered}. En ambos casos, se observa un comportamiento similar al descrito anteriormente: los tiempos de ejecución dependen principalmente de la longitud de \( S1 \). Esto es consistente independientemente de si las cadenas están parcialmente ordenadas o completamente desordenadas. 

El rendimiento del algoritmo mejora significativamente en casos donde:
\begin{enumerate}
    \item \( S1 \) y \( S2 \) comparten una gran cantidad de caracteres en las mismas posiciones.
    \item Uno de los strings está vacío o es considerablemente más corto que el otro.
\end{enumerate}

Estos escenarios representan casos interesantes para probar ambos enfoques, y se invita al lector a explorar estas posibilidades para comprender mejor las fortalezas y limitaciones de cada algoritmo.

\begin{figure}[H]
    \centering
    \input{tikz/plot2.tex}
    \caption{Gráfica de dispersión para \textit{semiordered dataset}, contrastando el uso del enfoque de fuerza bruta y el de programación dinámica.}
    \label{fig:grafico_dispersion_2}
\end{figure}

\begin{figure}[H]
    \centering
    \input{tikz/plot3.tex}
    \caption{Gráfica de dispersión para \textit{disordered dataset}, contrastando el uso del enfoque de fuerza bruta y el de programación dinámica.}
    \label{fig:grafico_dispersion_3}
\end{figure}

Finalmente, para replicar las gráficas presentadas, puede modificar las tuplas en la sección \textit{tikz} del tarball proporcionado, o bien, utilizar herramientas como Excel para generar automáticamente gráficos de dispersión ingresando los mismos datos. Esta última opción puede ser más conveniente si no está trabajando estrictamente con \LaTeX.
